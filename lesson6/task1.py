"""
Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
    Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
b. написать 3 варианта кода (один у вас уже есть);
проанализировать 3 варианта и выбрать оптимальный;

c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
    Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
d. написать общий вывод: какой из трёх вариантов лучше и почему.
"""
import sys
from random import randint
from memory_profiler import memory_usage

print(sys.version, sys.platform)
# 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] win32

"""
Я выбрал задачу 2 из урока 3, в которой было необходимо во втором массиве сохранить
индексы четных элементов первого массива. Данную задачу я решил через цикл for in
с использованием функции enumerate(). Это станет первым вариантом решения.
"""


# первый вариант
def even_index(arr):
    """
    Функция принимает в себя список чисел,
    индексы четных элементов которого будем
    помещать в новый список arr_index
    """
    arr_index = []
    for i, el in enumerate(arr):
        """
        Используем функцию enumerate(), которая 
        возвращает кортеж (индекс елемента, сам элемент).
        если элеммент el четный, то его индекс i
        помещаем в списко arr_index
        """
        if el % 2 == 0:
            arr_index.append(i)
    # return arr_index
    """
    Немного изменил, теперь функция возвращает объем памяти исходного списка, искомого списка
    и общий затраченный объем памяти
    """
    return f'Исходный список занял {sys.getsizeof(arr)} байт\n' \
           f'Искомый список индексов четных элементов занял {sys.getsizeof(arr_index)} байт\n' \
           f'Всего было занято {sys.getsizeof(arr) + sys.getsizeof(arr_index)}'


lst_20 = [randint(0, 10) for _ in range(0, 20)]


# print(sys.getsizeof(even_index(lst_10)))
# print(sys.getsizeof(even_index(lst_100)))
# print(sys.getsizeof(even_index(lst_1000)))

print(even_index(lst_20))
# результат
"""
Исходный список занял 248 байт
Искомый список индексов четных элементов занял 184 байт
Всего было занято 432

как видим под исходный списко занято очень много памяти.
Можно немного оптимизировать код, если функция будет генерировать
исходный список внутри себя а после его использования будет его удалять
"""


# второй вариант
def even_index_opt(n):
    arr = [randint(0, 10) for _ in range(0, n)]
    arr_index = []
    for i, el in enumerate(arr):
        if el % 2 == 0:
            arr_index.append(el)

    del arr
    try:
        a = sys.getsizeof(arr)
    except NameError:
        a = 0
    b = sys.getsizeof(arr_index)
    return f'После оптимизации исходный список занимает {a} байт\n' \
           f'Искомый список занимает {b} байт'


NUM = 20
print()
print(even_index_opt(NUM))
# результат
"""
После оптимизации исходный список занимает 0 байт
Искомый список занимает 184 байт

Таким образом мы освободили в памяти 248 байт
"""

# можно еще оптимизировать память, если return аменить на yield
# это видно если профилировать через memory_profiler


def mem_time_check(func):
    """
    Декоратор для замера памяти
    """
    def wrapper():
        # start = perf_counter()
        mem = memory_usage()
        func()
        # print(f'Время выполнения функции заняло {perf_counter() - start} сек.')
        print(f'Для выполнения функции потребовалось {memory_usage()[0] - mem[0]} MiB')
    return wrapper()


@mem_time_check
def even_index_return():
    arr = [randint(0, 10) for _ in range(0, 20)]
    arr_index = []
    for i, el in enumerate(arr):
        if el % 2 == 0:
            arr_index.append(el)
    del arr
    return arr_index


@mem_time_check
def even_index_yield():  # третий вариант
    arr = [randint(0, 10) for _ in range(0, 20)]
    arr_index = []
    for i, el in enumerate(arr):
        if el % 2 == 0:
            arr_index.append(el)
    del arr
    yield


# Результат
"""
Для выполнения функции потребовалось 0.0078125 MiB
Для выполнения функции потребовалось 0.0 MiB

Первый варинт - это функция с return
Второй - это функция с yield
"""
